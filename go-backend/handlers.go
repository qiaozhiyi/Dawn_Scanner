package main

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

// Handlers API处理器结构
type Handlers struct {
	TaskStore TaskStore
}

// NewHandlers 创建新的处理器
func NewHandlers(taskStore TaskStore) *Handlers {
	return &Handlers{
		TaskStore: taskStore,
	}
}

// SubmitScanTaskRequest 提交扫描任务请求结构
type SubmitScanTaskRequest struct {
	URL string `json:"url" binding:"required,url"`
}

// SubmitScanTaskResponse 提交扫描任务响应结构
type SubmitScanTaskResponse struct {
	TaskID string `json:"task_id"`
	Status string `json:"status"`
	URL    string `json:"url"`
}

// SubmitScanTask 提交新的扫描任务
func (h *Handlers) SubmitScanTask(c *gin.Context) {
	var req SubmitScanTaskRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid request format",
			"details": err.Error(),
		})
		return
	}

	scanner := NewScanner(h.TaskStore)
	task, err := scanner.CompleteScanFlow(req.URL)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to create scan task",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusCreated, SubmitScanTaskResponse{
		TaskID: task.ID,
		Status: string(task.Status),
		URL:    task.URL,
	})
}

// GetScanTaskResponse 获取扫描任务响应结构
type GetScanTaskResponse struct {
	TaskID      string      `json:"task_id"`
	Status      string      `json:"status"`
	URL         string      `json:"url"`
	CreatedAt   time.Time   `json:"created_at"`
	StartedAt   *time.Time  `json:"started_at,omitempty"`
	CompletedAt *time.Time  `json:"completed_at,omitempty"`
	Result      *Result     `json:"result,omitempty"`
	Error       string      `json:"error,omitempty"`
}

// GetScanTask 获取扫描任务状态和结果
func (h *Handlers) GetScanTask(c *gin.Context) {
	taskID := c.Param("id")

	task, err := h.TaskStore.GetTask(taskID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Task not found",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, GetScanTaskResponse{
		TaskID:      task.ID,
		Status:      string(task.Status),
		URL:         task.URL,
		CreatedAt:   task.CreatedAt,
		StartedAt:   task.StartedAt,
		CompletedAt: task.CompletedAt,
		Result:      task.Result,
		Error:       task.Error,
	})
}

// ListScanTasksResponse 列出扫描任务响应结构
type ListScanTasksResponse struct {
	Tasks []*GetScanTaskResponse `json:"tasks"`
}

// ListScanTasks 列出所有扫描任务
func (h *Handlers) ListScanTasks(c *gin.Context) {
	tasks, err := h.TaskStore.ListTasks()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to list scan tasks",
			"details": err.Error(),
		})
		return
	}

	taskResponses := make([]*GetScanTaskResponse, len(tasks))
	for i, task := range tasks {
		taskResponses[i] = &GetScanTaskResponse{
			TaskID:      task.ID,
			Status:      string(task.Status),
			URL:         task.URL,
			CreatedAt:   task.CreatedAt,
			StartedAt:   task.StartedAt,
			CompletedAt: task.CompletedAt,
			Result:      task.Result,
			Error:       task.Error,
		}
	}

	c.JSON(http.StatusOK, ListScanTasksResponse{
		Tasks: taskResponses,
	})
}

// DeleteScanTask 删除扫描任务
func (h *Handlers) DeleteScanTask(c *gin.Context) {
	taskID := c.Param("id")

	err := h.TaskStore.DeleteTask(taskID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Task not found",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Task deleted successfully",
	})
}

// executeScan 执行实际的扫描工作
func (h *Handlers) executeScan(taskID string) {
	// 获取任务
	task, err := h.TaskStore.GetTask(taskID)
	if err != nil {
		// 记录错误，但不返回，因为这是在goroutine中
		return
	}

	// 更新任务状态为运行中
	now := time.Now()
	task.Status = TaskRunning
	task.StartedAt = &now
	h.TaskStore.UpdateTask(task)

	// 模拟扫描过程 - 在实际实现中，这里会调用漏洞扫描逻辑
	// 可能会调用Python worker或其他扫描工具
	time.Sleep(2 * time.Second) // 模拟扫描时间

	// 扫描完成后更新任务状态
	completedAt := time.Now()
	task.Status = TaskCompleted
	task.CompletedAt = &completedAt

	// 这里应该包含实际的扫描结果
	// 为了演示，我们创建一个示例结果
	task.Result = &Result{
		Vulnerabilities: []Vulnerability{
			{
				ID:          "vuln-001",
				Type:        "SQL Injection",
				Severity:    "High",
				Description: "Potential SQL injection vulnerability detected",
				URL:         task.URL,
				Details:     "Input validation is not properly implemented for user inputs",
			},
			{
				ID:          "vuln-002",
				Type:        "XSS",
				Severity:    "Medium",
				Description: "Cross-site scripting vulnerability detected",
				URL:         task.URL,
				Details:     "Unsanitized user input in output context",
			},
		},
		Summary: "Found 2 vulnerabilities: 1 High severity, 1 Medium severity",
		Report:  "Full security report will be generated by LLM service",
	}

	h.TaskStore.UpdateTask(task)

	// 异步调用LLM服务生成详细报告
	go h.generateLLMReport(taskID)
}

// generateLLMReport 调用LLM服务生成详细报告
func (h *Handlers) generateLLMReport(taskID string) {
	// 获取任务
	task, err := h.TaskStore.GetTask(taskID)
	if err != nil {
		// 记录错误
		return
	}

	// 创建报告客户端
	client := NewReportClient()

	// 生成LLM报告
	err = client.IntegrationWithLLM(task)
	if err != nil {
		// 如果LLM服务不可用或生成报告失败，记录错误但不影响任务状态
		// 在实际实现中，可能需要重试机制
		return
	}

	// 更新任务，保存LLM生成的报告
	h.TaskStore.UpdateTask(task)
}
